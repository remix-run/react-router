import ts from "dedent";
import * as Path from "pathe";
import * as Pathe from "pathe/utils";

import * as Babel from "../vite/babel";
import type { Context } from "./context";
import * as Params from "./params";
import * as Route from "./route";
import type { RouteManifestEntry } from "../config/routes";

export type VirtualFile = { filename: string; content: string };

export function typesDirectory(ctx: Context) {
  return Path.join(ctx.rootDirectory, ".react-router/types");
}

export function generateFuture(ctx: Context): VirtualFile {
  const filename = Path.join(typesDirectory(ctx), "+future.ts");
  const content = ts`
    // Generated by React Router

    import "react-router";

    declare module "react-router" {
      interface Future {
        unstable_middleware: ${ctx.config.future.unstable_middleware}
      }
    }
  `;
  return { filename, content };
}

export function generateServerBuild(ctx: Context): VirtualFile {
  const filename = Path.join(typesDirectory(ctx), "+server-build.d.ts");
  const content = ts`
    // Generated by React Router

    declare module "virtual:react-router/server-build" {
      import { ServerBuild } from "react-router";
      export const assets: ServerBuild["assets"];
      export const assetsBuildDirectory: ServerBuild["assetsBuildDirectory"];
      export const basename: ServerBuild["basename"];
      export const entry: ServerBuild["entry"];
      export const future: ServerBuild["future"];
      export const isSpaMode: ServerBuild["isSpaMode"];
      export const prerender: ServerBuild["prerender"];
      export const publicPath: ServerBuild["publicPath"];
      export const routeDiscovery: ServerBuild["routeDiscovery"];
      export const routes: ServerBuild["routes"];
      export const ssr: ServerBuild["ssr"];
      export const unstable_getCriticalCss: ServerBuild["unstable_getCriticalCss"];
    }
  `;
  return { filename, content };
}

const { t } = Babel;
export function generatePages(ctx: Context): VirtualFile {
  const filename = Path.join(typesDirectory(ctx), "+pages.ts");

  const fullpaths = new Set<string>();
  Object.values(ctx.config.routes).forEach((route) => {
    if (route.id !== "root" && !route.path) return;
    const lineage = Route.lineage(ctx.config.routes, route);
    const fullpath = Route.fullpath(lineage);
    fullpaths.add(fullpath);
  });

  const pagesType = t.tsTypeAliasDeclaration(
    t.identifier("Pages"),
    null,
    t.tsTypeLiteral(
      Array.from(fullpaths).map((fullpath) => {
        return t.tsPropertySignature(
          t.stringLiteral(fullpath),
          t.tsTypeAnnotation(
            t.tsTypeLiteral([
              t.tsPropertySignature(
                t.identifier("params"),
                t.tsTypeAnnotation(paramsType(fullpath))
              ),
            ])
          )
        );
      })
    )
  );

  const content =
    ts`
      // Generated by React Router

      import "react-router"

      declare module "react-router" {
        interface Register {
          pages: Pages
        }
      }
    ` +
    "\n\n" +
    Babel.generate(pagesType).code;
  return { filename, content };
}

export function generateRoutes(ctx: Context): VirtualFile {
  const filename = Path.join(typesDirectory(ctx), "+routes-pre.ts");
  const routesType = t.tsTypeAliasDeclaration(
    t.identifier("routesPre"),
    null,
    t.tsTypeLiteral(
      Object.values(ctx.config.routes).map((route) => {
        return t.tsPropertySignature(
          t.stringLiteral(route.id),
          t.tsTypeAnnotation(
            t.tsTypeLiteral([
              t.tsPropertySignature(
                t.identifier("parentId"),
                t.tsTypeAnnotation(
                  route.parentId
                    ? t.tsLiteralType(t.stringLiteral(route.parentId))
                    : t.tsUndefinedKeyword()
                )
              ),
              t.tsPropertySignature(
                t.identifier("path"),
                t.tsTypeAnnotation(
                  route.path
                    ? t.tsLiteralType(t.stringLiteral(route.path))
                    : t.tsUndefinedKeyword()
                )
              ),
              t.tsPropertySignature(
                t.identifier("params"),
                t.tsTypeAnnotation(paramsType(route.path ?? ""))
              ),
              t.tsPropertySignature(
                t.identifier("index"),
                t.tsTypeAnnotation(
                  t.tsLiteralType(t.booleanLiteral(route.index ?? false))
                )
              ),
              t.tsPropertySignature(
                t.identifier("file"),
                t.tsTypeAnnotation(t.tsLiteralType(t.stringLiteral(route.file)))
              ),
            ])
          )
        );
      })
    )
  );
  const content =
    ts`
      // Generated by React Router

      import "react-router"

      declare module "react-router" {
        interface Register {
          routesPre: routesPre
        }
      }
    ` +
    "\n\n" +
    Babel.generate(routesType).code;
  return { filename, content };
}

export function generateRouteModuleAnnotations(
  ctx: Context
): Array<VirtualFile> {
  return Object.values(ctx.config.routes)
    .filter((route) => isRouteInAppDirectory(ctx, route))
    .map((route) => {
      const filename = getRouteModuleAnnotationsFilepath(ctx, route);

      const parents = getParents(ctx, route);

      const content = ts`
        // Generated by React Router

        import type {
          Params,
          RouteModuleAnnotations,
          CreateLoaderData,
          CreateActionData,
        } from "react-router/internal";

        ${parents.map((parent) => parent.import).join("\n" + "  ".repeat(3))}
        type Parents = [${parents.map((parent) => parent.name).join(", ")}]

        type Id = "${route.id}"
        type Module = typeof import("../${Pathe.filename(route.file)}.js")

        export type unstable_Props = {
          params: Params[Id]
          loaderData: CreateLoaderData<Module>
          actionData: CreateActionData<Module>
        }

        type Annotations = RouteModuleAnnotations<unstable_Props & {
          parents: Parents,
          module: Module,
        }>;

        export namespace Route {
          // links
          export type LinkDescriptors = Annotations["LinkDescriptors"];
          export type LinksFunction = Annotations["LinksFunction"];

          // meta
          export type MetaArgs = Annotations["MetaArgs"];
          export type MetaDescriptors = Annotations["MetaDescriptors"];
          export type MetaFunction = Annotations["MetaFunction"];

          // headers
          export type HeadersArgs = Annotations["HeadersArgs"];
          export type HeadersFunction = Annotations["HeadersFunction"];

          // unstable_middleware
          export type unstable_MiddlewareFunction = Annotations["unstable_MiddlewareFunction"];

          // unstable_clientMiddleware
          export type unstable_ClientMiddlewareFunction = Annotations["unstable_ClientMiddlewareFunction"];

          // loader
          export type LoaderArgs = Annotations["LoaderArgs"];

          // clientLoader
          export type ClientLoaderArgs = Annotations["ClientLoaderArgs"];

          // action
          export type ActionArgs = Annotations["ActionArgs"];

          // clientAction
          export type ClientActionArgs = Annotations["ClientActionArgs"];

          // HydrateFallback
          export type HydrateFallbackProps = Annotations["HydrateFallbackProps"];

          // Component
          export type ComponentProps = Annotations["ComponentProps"];

          // ErrorBoundary
          export type ErrorBoundaryProps = Annotations["ErrorBoundaryProps"];
        }
      `;
      return { filename, content };
    });
}

function isRouteInAppDirectory(ctx: Context, route: RouteManifestEntry) {
  const absoluteRoutePath = Path.resolve(ctx.config.appDirectory, route.file);
  return absoluteRoutePath.startsWith(ctx.config.appDirectory);
}

function getRouteModuleAnnotationsFilepath(
  ctx: Context,
  route: RouteManifestEntry
) {
  return Path.join(
    typesDirectory(ctx),
    Path.relative(ctx.rootDirectory, ctx.config.appDirectory),
    Path.dirname(route.file),
    "+types/" + Pathe.filename(route.file) + ".ts"
  );
}

function getParents(ctx: Context, route: RouteManifestEntry) {
  const typesPath = getRouteModuleAnnotationsFilepath(ctx, route);

  const lineage = Route.lineage(ctx.config.routes, route);

  const parents = lineage.slice(0, -1);
  return parents.map((parent, i) => {
    const rel = Path.relative(
      Path.dirname(typesPath),
      getRouteModuleAnnotationsFilepath(ctx, parent)
    );

    let source = noExtension(rel);
    if (!source.startsWith("../")) source = "./" + source;

    const name = `Parent${i}`;
    return {
      name,
      import: `import type { unstable_Props as ${name} } from "${source}.js"`,
    };
  });
}

function noExtension(path: string) {
  return Path.join(Path.dirname(path), Pathe.filename(path));
}

function paramsType(path: string) {
  const params = Params.parse(path);
  return t.tsTypeLiteral(
    Object.entries(params).map(([param, isRequired]) => {
      const property = t.tsPropertySignature(
        t.stringLiteral(param),
        t.tsTypeAnnotation(t.tsStringKeyword())
      );
      property.optional = !isRequired;
      return property;
    })
  );
}
