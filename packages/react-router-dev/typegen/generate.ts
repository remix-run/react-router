import ts from "dedent";
import * as Path from "pathe";
import * as Pathe from "pathe/utils";

import * as Babel from "../vite/babel";
import type { Context } from "./context";
import * as Params from "./params";
import * as Route from "./route";
import type { RouteManifestEntry } from "../config/routes";

export type VirtualFile = { filename: string; content: string };

export function typesDirectory(ctx: Context) {
  return Path.join(ctx.rootDirectory, ".react-router/types");
}

export function generateFuture(ctx: Context): VirtualFile {
  const filename = Path.join(typesDirectory(ctx), "+future.ts");
  const content = ts`
    // Generated by React Router

    import "react-router";

    declare module "react-router" {
      interface Future {
        unstable_middleware: ${ctx.config.future.unstable_middleware}
      }
    }
  `;
  return { filename, content };
}

export function generateServerBuild(ctx: Context): VirtualFile {
  const filename = Path.join(typesDirectory(ctx), "+server-build.d.ts");
  const content = ts`
    // Generated by React Router

    declare module "virtual:react-router/server-build" {
      import { ServerBuild } from "react-router";
      export const assets: ServerBuild["assets"];
      export const assetsBuildDirectory: ServerBuild["assetsBuildDirectory"];
      export const basename: ServerBuild["basename"];
      export const entry: ServerBuild["entry"];
      export const future: ServerBuild["future"];
      export const isSpaMode: ServerBuild["isSpaMode"];
      export const prerender: ServerBuild["prerender"];
      export const publicPath: ServerBuild["publicPath"];
      export const routeDiscovery: ServerBuild["routeDiscovery"];
      export const routes: ServerBuild["routes"];
      export const ssr: ServerBuild["ssr"];
      export const unstable_getCriticalCss: ServerBuild["unstable_getCriticalCss"];
    }
  `;
  return { filename, content };
}

const { t } = Babel;
export function generateRoutes(ctx: Context): Array<VirtualFile> {
  // precompute
  const fileToRoutes = new Map<string, Set<string>>();
  const lineages = new Map<string, Array<RouteManifestEntry>>();
  const allPages = new Set<string>();
  const routeToPages = new Map<string, Set<string>>();
  for (const route of Object.values(ctx.config.routes)) {
    // fileToRoutes
    let routeIds = fileToRoutes.get(route.file);
    if (!routeIds) {
      routeIds = new Set();
      fileToRoutes.set(route.file, routeIds);
    }
    routeIds.add(route.id);

    // lineages
    const lineage = Route.lineage(ctx.config.routes, route);
    lineages.set(route.id, lineage);

    // pages
    const fullpath = Route.fullpath(lineage);
    if (!fullpath) continue;
    const pages = explodeOptionalSegments(fullpath);
    pages.forEach((page) => allPages.add(page));

    // routePages
    lineage.forEach(({ id }) => {
      let routePages = routeToPages.get(id);
      if (!routePages) {
        routePages = new Set<string>();
        routeToPages.set(id, routePages);
      }
      pages.forEach((page) => routePages.add(page));
    });
  }

  // +routes.ts
  const routesTs: VirtualFile = {
    filename: Path.join(typesDirectory(ctx), "+routes.ts"),
    content:
      ts`
        // Generated by React Router

        import "react-router"

        declare module "react-router" {
          interface Register {
            pages: Pages
            routeFiles: RouteFiles
          }
        }
      ` +
      "\n\n" +
      Babel.generate(pagesType(allPages)).code +
      "\n\n" +
      Babel.generate(routeFilesType({ fileToRoutes, routeToPages })).code,
  };

  // **/+types/*.ts
  const allAnnotations: Array<VirtualFile> = Array.from(fileToRoutes.entries())
    .filter(([file]) => isInAppDirectory(ctx, file))
    .map(([file, routeIds]) =>
      getRouteAnnotations({ ctx, file, routeIds, lineages })
    );

  return [routesTs, ...allAnnotations];
}

function pagesType(pages: Set<string>) {
  return t.tsTypeAliasDeclaration(
    t.identifier("Pages"),
    null,
    t.tsTypeLiteral(
      Array.from(pages).map((page) => {
        return t.tsPropertySignature(
          t.stringLiteral(page),
          t.tsTypeAnnotation(
            t.tsTypeLiteral([
              t.tsPropertySignature(
                t.identifier("params"),
                t.tsTypeAnnotation(paramsType(page))
              ),
            ])
          )
        );
      })
    )
  );
}

function routeFilesType({
  fileToRoutes,
  routeToPages,
}: {
  fileToRoutes: Map<string, Set<string>>;
  routeToPages: Map<string, Set<string>>;
}) {
  return t.tsTypeAliasDeclaration(
    t.identifier("RouteFiles"),
    null,
    t.tsTypeLiteral(
      Array.from(fileToRoutes).map(([file, routeIds]) =>
        t.tsPropertySignature(
          t.stringLiteral(file),
          t.tsTypeAnnotation(
            t.tsUnionType(
              Array.from(routeIds).map((routeId) => {
                const pages = routeToPages.get(routeId) ?? new Set();
                return t.tsTypeLiteral([
                  t.tsPropertySignature(
                    t.identifier("id"),
                    t.tsTypeAnnotation(
                      t.tsLiteralType(t.stringLiteral(routeId))
                    )
                  ),
                  t.tsPropertySignature(
                    t.identifier("page"),
                    t.tsTypeAnnotation(
                      pages
                        ? t.tsUnionType(
                            Array.from(pages).map((page) =>
                              t.tsLiteralType(t.stringLiteral(page))
                            )
                          )
                        : t.tsNeverKeyword()
                    )
                  ),
                ]);
              })
            )
          )
        )
      )
    )
  );
}

function isInAppDirectory(ctx: Context, routeFile: string): boolean {
  const path = Path.resolve(ctx.config.appDirectory, routeFile);
  return path.startsWith(ctx.config.appDirectory);
}

function getRouteAnnotations({
  ctx,
  file,
  routeIds,
  lineages,
}: {
  ctx: Context;
  file: string;
  routeIds: Set<string>;
  lineages: Map<string, Array<RouteManifestEntry>>;
}) {
  const filename = Path.join(
    typesDirectory(ctx),
    Path.relative(ctx.rootDirectory, ctx.config.appDirectory),
    Path.dirname(file),
    "+types",
    Pathe.filename(file) + ".ts"
  );

  const matchesType = t.tsTypeAliasDeclaration(
    t.identifier("Matches"),
    null,
    t.tsUnionType(
      Array.from(routeIds).map((routeId) => {
        const lineage = lineages.get(routeId)!;
        return t.tsTupleType(
          lineage.map((route) =>
            t.tsTypeLiteral([
              t.tsPropertySignature(
                t.identifier("id"),
                t.tsTypeAnnotation(t.tsLiteralType(t.stringLiteral(route.id)))
              ),
              t.tsPropertySignature(
                t.identifier("module"),
                t.tsTypeAnnotation(
                  t.tsTypeQuery(
                    t.tsImportType(
                      t.stringLiteral(
                        relativeImportSource(
                          rootDirsPath(ctx, filename),
                          Path.resolve(ctx.config.appDirectory, route.file)
                        )
                      )
                    )
                  )
                )
              ),
            ])
          )
        );
      })
    )
  );

  const routeImportSource = relativeImportSource(
    rootDirsPath(ctx, filename),
    Path.resolve(ctx.config.appDirectory, file)
  );

  const content =
    ts`
      // Generated by React Router

      import type { GetInfo, GetAnnotations } from "react-router/internal";

      type Module = typeof import("${routeImportSource}")

      type Info = GetInfo<{
        file: "${file}",
        module: Module
      }>
    ` +
    "\n\n" +
    Babel.generate(matchesType).code +
    "\n\n" +
    ts`
      type Annotations = GetAnnotations<Info & { module: Module, matches: Matches }>;

      export namespace Route {
        // links
        export type LinkDescriptors = Annotations["LinkDescriptors"];
        export type LinksFunction = Annotations["LinksFunction"];

        // meta
        export type MetaArgs = Annotations["MetaArgs"];
        export type MetaDescriptors = Annotations["MetaDescriptors"];
        export type MetaFunction = Annotations["MetaFunction"];

        // headers
        export type HeadersArgs = Annotations["HeadersArgs"];
        export type HeadersFunction = Annotations["HeadersFunction"];

        // unstable_middleware
        export type unstable_MiddlewareFunction = Annotations["unstable_MiddlewareFunction"];

        // unstable_clientMiddleware
        export type unstable_ClientMiddlewareFunction = Annotations["unstable_ClientMiddlewareFunction"];

        // loader
        export type LoaderArgs = Annotations["LoaderArgs"];

        // clientLoader
        export type ClientLoaderArgs = Annotations["ClientLoaderArgs"];

        // action
        export type ActionArgs = Annotations["ActionArgs"];

        // clientAction
        export type ClientActionArgs = Annotations["ClientActionArgs"];

        // HydrateFallback
        export type HydrateFallbackProps = Annotations["HydrateFallbackProps"];

        // Component
        export type ComponentProps = Annotations["ComponentProps"];

        // ErrorBoundary
        export type ErrorBoundaryProps = Annotations["ErrorBoundaryProps"];
      }
    `;
  return { filename, content };
}

function relativeImportSource(from: string, to: string) {
  let path = Path.relative(Path.dirname(from), to);
  // no extension
  path = Path.join(Path.dirname(path), Pathe.filename(path));
  if (!path.startsWith("../")) path = "./" + path;

  return path + ".js";
}

function rootDirsPath(ctx: Context, typesPath: string): string {
  const rel = Path.relative(typesDirectory(ctx), typesPath);
  return Path.join(ctx.rootDirectory, rel);
}

function paramsType(path: string) {
  const params = Params.parse(path);
  return t.tsTypeLiteral(
    Object.entries(params).map(([param, isRequired]) => {
      const property = t.tsPropertySignature(
        t.stringLiteral(param),
        t.tsTypeAnnotation(t.tsStringKeyword())
      );
      property.optional = !isRequired;
      return property;
    })
  );
}

// https://github.com/remix-run/react-router/blob/7a7f4b11ca8b26889ad328ba0ee5a749b0c6939e/packages/react-router/lib/router/utils.ts#L894C1-L937C2
function explodeOptionalSegments(path: string): string[] {
  let segments = path.split("/");
  if (segments.length === 0) return [];

  let [first, ...rest] = segments;

  // Optional path segments are denoted by a trailing `?`
  let isOptional = first.endsWith("?");
  // Compute the corresponding required segment: `foo?` -> `foo`
  let required = first.replace(/\?$/, "");

  if (rest.length === 0) {
    // Interpret empty string as omitting an optional segment
    // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
    return isOptional ? [required, ""] : [required];
  }

  let restExploded = explodeOptionalSegments(rest.join("/"));

  let result: string[] = [];

  // All child paths with the prefix.  Do this for all children before the
  // optional version for all children, so we get consistent ordering where the
  // parent optional aspect is preferred as required.  Otherwise, we can get
  // child sections interspersed where deeper optional segments are higher than
  // parent optional segments, where for example, /:two would explode _earlier_
  // then /:one.  By always including the parent as required _for all children_
  // first, we avoid this issue
  result.push(
    ...restExploded.map((subpath) =>
      subpath === "" ? required : [required, subpath].join("/")
    )
  );

  // Then, if this is an optional value, add all child versions without
  if (isOptional) {
    result.push(...restExploded);
  }

  // for absolute paths, ensure `/` instead of empty segment
  return result.map((exploded) =>
    path.startsWith("/") && exploded === "" ? "/" : exploded
  );
}
